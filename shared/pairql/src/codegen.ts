#!/usr/bin/env tsx
import fs from 'node:fs';
import path from 'node:path';
import type { CodegenOutput, Domain } from './types';

interface DomainConfig {
  domain: Domain;
  clientName: string;
  codegenEndpoint: string;
  authHeader: string;
}

const PACKAGE_ROOT = path.resolve(__dirname, `..`);

const DOMAINS: DomainConfig[] = [
  {
    domain: `dashboard`,
    clientName: `DashboardClient`,
    codegenEndpoint: `http://127.0.0.1:8080/dashboard-ts-codegen`,
    authHeader: `X-AdminToken`,
  },
  {
    domain: `admin`,
    clientName: `AdminClient`,
    codegenEndpoint: `http://127.0.0.1:8080/admin-ts-codegen`,
    authHeader: `X-AdminToken`,
  },
];

async function main(): Promise<void> {
  const args = process.argv.slice(2);
  const domainArg = args.find((arg) => arg.startsWith(`--domain=`));
  const targetDomain = domainArg?.split(`=`)[1] as Domain | undefined;

  const domainsToGenerate = targetDomain
    ? DOMAINS.filter((d) => d.domain === targetDomain)
    : DOMAINS;

  if (domainsToGenerate.length === 0) {
    console.error(`No domains to generate. Available: ${DOMAINS.map((d) => d.domain).join(`, `)}`);
    process.exit(1);
  }

  const promises = domainsToGenerate.map(async (config) => {
    console.log(`Generating TypeScript client for domain: ${config.domain}`);
    try {
      await generateDomain(config);
      console.log(`Successfully generated ${config.domain} client`);
    } catch (error) {
      console.error(`Failed to generate ${config.domain}:`, error);
      throw error;
    }
  });

  await Promise.all(promises);
  console.log(`\nCodegen complete!`);
}

async function generateDomain(config: DomainConfig): Promise<void> {
  const domainDir = path.join(PACKAGE_ROOT, `src`, config.domain);
  cleanDir(domainDir);

  const output = await fetchCodegenData(config.codegenEndpoint);
  const sharedTypes = Object.keys(output.shared).sort();

  const pairIndexLines: string[] = [];
  const clientMethods: string[] = [];

  if (sharedTypes.length > 0) {
    pairIndexLines.push(`export * from './shared';`);
    let sharedFile = Object.values(output.shared).join(`\n\n`);
    sharedFile = sortShared(spaced(sharedFile));
    fs.writeFileSync(
      path.join(domainDir, `shared.ts`),
      autogenerated(sharedFile),
    );
  }

  const pairsDir = path.join(domainDir, `pairs`);
  fs.mkdirSync(pairsDir, { recursive: true });

  for (const [pairName, pair] of Object.entries(output.pairs).sort(([a], [b]) => a.localeCompare(b))) {
    const sharedImports = findSharedImports(pair.pair, sharedTypes);
    let sharedImport = ``;
    if (sharedImports.length > 0) {
      sharedImport = `import type { ${sharedImports.join(`, `)} } from '../shared';\n`;
    }
    fs.writeFileSync(
      path.join(pairsDir, `${pairName}.ts`),
      autogenerated(spaced(sharedImport, expand(pair.pair))),
    );

    clientMethods.push(pair.fetcher);
    pairIndexLines.push(`export * from './pairs/${pairName}';`);
  }

  fs.writeFileSync(
    path.join(domainDir, `${config.clientName}.ts`),
    autogenerated(generateClientFile(config, clientMethods.sort())),
  );

  fs.writeFileSync(
    path.join(domainDir, `index.ts`),
    autogenerated(generatePairsIndexFile(pairIndexLines)),
  );

  fs.writeFileSync(
    path.join(PACKAGE_ROOT, `${config.domain}.ts`),
    autogenerated(generateDomainEntryFile(config)),
  );
}

async function fetchCodegenData(endpoint: string): Promise<CodegenOutput> {
  const response = await fetch(endpoint);
  if (!response.ok) {
    throw new Error(`Failed to fetch codegen data from ${endpoint}: ${response.status}`);
  }
  return response.json() as Promise<CodegenOutput>;
}

function cleanDir(dir: string): void {
  if (fs.existsSync(dir)) {
    fs.rmSync(dir, { recursive: true });
  }
  fs.mkdirSync(dir, { recursive: true });
  fs.mkdirSync(path.join(dir, `pairs`), { recursive: true });
}

function findSharedImports(pairCode: string, sharedTypes: string[]): string[] {
  const imports: string[] = [];
  for (const typeName of sharedTypes) {
    const regex = new RegExp(`\\b${typeName}\\b`);
    if (
      pairCode.match(regex) &&
      !pairCode.includes(`'${typeName}'`) &&
      !pairCode.includes(`interface ${typeName}`)
    ) {
      imports.push(typeName);
    }
  }
  return imports;
}

function generateClientFile(config: DomainConfig, methods: string[]): string {
  return `import type { Env } from '../types';
import type Result from '../Result';
import Client from '../Client';
import type * as P from './pairs';

export default class ${config.clientName} extends Client {
  public constructor(env: Env, getToken: () => string | undefined) {
    super(env, \`${config.domain}\`, getToken, \`${config.authHeader}\`);
  }

  public static web(href: string, getToken: () => string | undefined): ${config.clientName} {
    const env = Client.inferEnv(href);
    if (env !== \`prod\`) {
      console.log(\`[,] Gertrude PairQL client configured for env: \${env.toUpperCase()}\`);
    }
    return new ${config.clientName}(env, getToken);
  }

${methods.map((m) => `  public ${m}`).join(`\n\n`)}
}

export type { P };
`;
}

function generatePairsIndexFile(pairLines: string[]): string {
  return pairLines.join(`\n`) + `\n`;
}

function generateDomainEntryFile(config: DomainConfig): string {
  return `import type * as T from './src/${config.domain}/pairs';
import ${config.clientName} from './src/${config.domain}/${config.clientName}';
export type { T };
export default ${config.clientName};
`;
}

function autogenerated(file: string): string {
  return `// auto-generated, do not edit\n${file}`;
}

function spaced(...strings: string[]): string {
  return strings.filter(Boolean).join(`\n\n`);
}

function expand(paircode: string): string {
  return paircode.replace(/Array<{ /g, `Array<{\n`).replace(/{ /g, `{\n`);
}

function sortShared(code: string): string {
  const parts = code.split(`\n\n`).map((chunk) => {
    const lines = chunk.split(`\n`);
    const firstLine = lines[0] ?? ``;
    const typeName = firstLine.replace(/export (:?type|interface|enum) ([^ ]+) .*/, `$2`);
    return { typeName, chunk };
  });
  parts.sort((a, b) => a.typeName.localeCompare(b.typeName));
  return parts.map((p) => p.chunk).join(`\n\n`);
}

main().catch((error) => {
  console.error(error);
  process.exit(1);
});
