#!/usr/bin/env tsx
/* eslint-disable no-console */
import fs from 'node:fs';
import path from 'node:path';
import type { CodegenOutput, Domain } from './types';

interface DomainConfig {
  domain: Domain;
  clientName: string;
  cypressInterceptFile?: string;
}

const PACKAGE_ROOT = new URL(`..`, import.meta.url).pathname;

const DOMAINS: DomainConfig[] = [
  {
    domain: `dashboard`,
    clientName: `DashboardClient`,
    cypressInterceptFile: path.resolve(
      PACKAGE_ROOT,
      `../../dash/app/cypress/support/intercept.ts`,
    ),
  },
  {
    domain: `admin`,
    clientName: `AdminClient`,
  },
];

async function main(): Promise<void> {
  const promises = DOMAINS.map(async (config) => {
    console.log(`Generating TypeScript client for domain: ${config.domain}`);
    try {
      await generateDomain(config);
      console.log(`Successfully generated ${config.domain} client`);
    } catch (error) {
      console.error(`Failed to generate ${config.domain}:`, error);
      throw error;
    }
  });

  await Promise.all(promises);
  console.log(`\nCodegen complete!`);
}

async function generateDomain(config: DomainConfig): Promise<void> {
  const domainDir = path.join(PACKAGE_ROOT, `src`, config.domain);
  cleanDir(domainDir);

  const endpoint = `http://127.0.0.1:8080/${config.domain}-ts-codegen`;
  const output = await fetchCodegenData(endpoint);
  const sharedTypes = Object.keys(output.shared).sort();
  const pairNames = Object.keys(output.pairs).sort();

  const pairIndexLines: string[] = [];
  const clientMethods: string[] = [];

  if (sharedTypes.length > 0) {
    pairIndexLines.push(`export * from './shared';`);
    //
    // prevent multiple definitions of ServerPqlError
    const filteredShared = Object.entries(output.shared)
      .filter(([name]) => name !== `ServerPqlError`)
      .map(([, code]) => code);
    let sharedFile = filteredShared.join(`\n\n`);
    sharedFile = sortShared(spaced(sharedFile));

    // add type imports for UUID and ISODateString if used
    const sharedTypeImports = findTypeImports(sharedFile);
    const imports: string[] = [];
    if (sharedTypeImports.length > 0) {
      imports.push(`import type { ${sharedTypeImports.join(`, `)} } from '../types';`);
    }

    imports.push(`export type { ServerPqlError } from '../PqlError';`);
    if (imports.length > 0) {
      sharedFile = imports.join(`\n`) + `\n\n` + sharedFile;
    }

    fs.writeFileSync(path.join(domainDir, `shared.ts`), autogenerated(sharedFile));
  }

  const pairsDir = path.join(domainDir, `pairs`);
  fs.mkdirSync(pairsDir, { recursive: true });

  for (const [pairName, pair] of Object.entries(output.pairs).sort(([a], [b]) =>
    a.localeCompare(b),
  )) {
    const sharedImports = findSharedImports(pair.pair, sharedTypes);
    const typeImports = findTypeImports(pair.pair);
    const imports: string[] = [];
    if (typeImports.length > 0) {
      imports.push(`import type { ${typeImports.join(`, `)} } from '../../types';`);
    }
    if (sharedImports.length > 0) {
      imports.push(`import type { ${sharedImports.join(`, `)} } from '../shared';`);
    }
    const importBlock = imports.length > 0 ? imports.join(`\n`) + `\n` : ``;
    fs.writeFileSync(
      path.join(pairsDir, `${pairName}.ts`),
      autogenerated(spaced(importBlock, expand(pair.pair))),
    );

    clientMethods.push(pair.fetcher);
    pairIndexLines.push(`export * from './pairs/${pairName}';`);
  }

  fs.writeFileSync(
    path.join(domainDir, `${config.clientName}.ts`),
    autogenerated(generateClientFile(config, clientMethods.sort())),
  );

  fs.writeFileSync(
    path.join(domainDir, `index.ts`),
    autogenerated(generatePairsIndexFile(pairIndexLines)),
  );

  fs.writeFileSync(
    path.join(PACKAGE_ROOT, `${config.domain}.ts`),
    autogenerated(generateDomainEntryFile(config)),
  );

  if (config.cypressInterceptFile) {
    const cypressContent = generateCypressInterceptFile(config, pairNames, `@dash/types`);
    fs.writeFileSync(config.cypressInterceptFile, autogenerated(cypressContent));
  }
}

async function fetchCodegenData(endpoint: string): Promise<CodegenOutput> {
  const response = await fetch(endpoint);
  if (!response.ok) {
    throw new Error(`Failed to fetch codegen data from ${endpoint}: ${response.status}`);
  }
  return response.json() as Promise<CodegenOutput>;
}

function cleanDir(dir: string): void {
  if (fs.existsSync(dir)) {
    fs.rmSync(dir, { recursive: true });
  }
  fs.mkdirSync(dir, { recursive: true });
  fs.mkdirSync(path.join(dir, `pairs`), { recursive: true });
}

function findSharedImports(pairCode: string, sharedTypes: string[]): string[] {
  const imports: string[] = [];
  for (const typeName of sharedTypes) {
    const regex = new RegExp(`\\b${typeName}\\b`);
    if (
      pairCode.match(regex) &&
      !pairCode.includes(`'${typeName}'`) &&
      !pairCode.includes(`interface ${typeName}`)
    ) {
      imports.push(typeName);
    }
  }
  return imports;
}

function findTypeImports(pairCode: string): string[] {
  const types: string[] = [];
  if (/\bUUID\b/.test(pairCode)) {
    types.push(`UUID`);
  }
  if (/\bISODateString\b/.test(pairCode)) {
    types.push(`ISODateString`);
  }
  return types;
}

function generateClientFile(config: DomainConfig, methods: string[]): string {
  return `import type * as P from '.';
import type Result from '../Result';
import type { PrepareRequest } from '../types';
import type { ClientAuth as Auth } from './shared';
import Client from '../Client';

export default class ${config.clientName} extends Client<Auth> {
  public constructor(endpoint: string, prepareRequest: PrepareRequest<Auth>) {
    super(endpoint, \`${config.domain}\`, prepareRequest);
  }

${methods.map((m) => `  public ${m}`).join(`\n\n`)}
}

export type { P };
`;
}

function generatePairsIndexFile(pairLines: string[]): string {
  // Add UUID and ISODateString type exports at the top
  const typeExports = `export type { UUID, ISODateString } from '../types';`;
  return typeExports + `\n` + pairLines.join(`\n`) + `\n`;
}

function generateDomainEntryFile(config: DomainConfig): string {
  return `import type * as P from './src/${config.domain}';
import ${config.clientName} from './src/${config.domain}/${config.clientName}';
export type { P as T };
export default ${config.clientName};
`;
}

function generateCypressInterceptFile(
  config: DomainConfig,
  pairNames: string[],
  typesImport: string,
): string {
  const lines: string[] = [];

  lines.push(`import type * as T from '${typesImport}';`);
  lines.push(``);

  // Generate overloads for interceptPql
  for (const name of pairNames) {
    lines.push(
      `export function interceptPql(slug: \`${name}\`, output: T.${name}.Output): void;`,
    );
  }

  // Implementation
  lines.push(`\nexport function interceptPql(slug: string, output: any): void {`);
  lines.push(
    `  // cypress chokes on the empty object, doesn't understand it should reply w/ it`,
  );
  lines.push(`  const res = JSON.stringify(output) === \`{}\` ? \`{}\` : output;`);
  lines.push(
    `  cy.intercept(\`/pairql/${config.domain}/\${slug}\`, (req) => req.reply(res)).as(slug);`,
  );
  lines.push(`}`);
  lines.push(``);

  // Generate forcePqlErr
  const slugUnion = pairNames.map((n) => `\`${n}\``).join(`\n    | `);
  lines.push(`export function forcePqlErr(`);
  lines.push(`  slug:`);
  lines.push(`    | ${slugUnion},`);
  lines.push(`  details: Record<string, any> = {},`);
  lines.push(`): void {`);
  lines.push(
    `  cy.intercept(\`/pairql/${config.domain}/\${slug}\`, { __cyStubbedError: true, ...details });`,
  );
  lines.push(`}`);

  return lines.join(`\n`) + `\n`;
}

function autogenerated(file: string): string {
  return `// auto-generated, do not edit\n${file}`;
}

function spaced(...strings: string[]): string {
  return strings.filter(Boolean).join(`\n\n`);
}

function expand(paircode: string): string {
  return paircode.replace(/Array<{ /g, `Array<{\n`).replace(/{ /g, `{\n`);
}

function sortShared(code: string): string {
  const parts = code.split(`\n\n`).map((chunk) => {
    const lines = chunk.split(`\n`);
    const firstLine = lines[0] ?? ``;
    const typeName = firstLine.replace(/export (:?type|interface|enum) ([^ ]+) .*/, `$2`);
    return { typeName, chunk };
  });
  parts.sort((a, b) => a.typeName.localeCompare(b.typeName));
  return parts.map((p) => p.chunk).join(`\n\n`);
}

main().catch((error) => {
  console.error(error);
  process.exit(1);
});
